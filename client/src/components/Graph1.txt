
import React, { useEffect, useRef, useState, useCallback } from 'react';
import axios from "axios";
import Bar from "./Bar";
import DateComp from "./Date";
import LineGraph from "./LineGraph";
import VertAxis from "./VertAxis";
import { useAppContext } from "../AppContext";

//TODO: fix loading, horizontalize dates, display bars
function Graph({ sensor_id, start, end }) {
	const {graphUtil} = require("../graphUtil");
	const {getObj} = require("../getObj");

	const [nBars, setNBars] = useState(50);
	const [bars, setBars] = useState([]);
	const [AQI, setAQI] = useState([]);
	const [dates, setDates] = useState([]);
	const [gradient, setGradient] = useState("powderblue");
    	const [loading, setLoading] = useState(false);
    	const [error, setError] = useState(null);
	const [max, setMax] = useState(0);


	const [lines, setLines] = useState([]); //entry format: {"data": [], "sensor": []}
	const {setGlobalLineBool} = useAppContext();
	const [lineBool, setLineBool] = useState(false);

	const [axes, setAxes] = useState({"xVals": [], "xPos": [], "yVals": []});
	const height = 200;
	const width = 500;

	const divRef = useRef(null);
	const [divSize, setDivSize] = useState({width: 0, height: 0});
	const buttonRef = useRef(null);
	const [buttonHeight, setButtonHeight] = useState(0);
	const xAxisRef = useRef(null);
	const [xHeight, setXHeight] = useState(0);

	//get data from api
	useEffect(() => {
            /*console.log(sensor_id);
	    //console.log(typeof start);
	    //console.log(typeof end);*/

	    if (lineBool) {/*TODO: CHECK IF SENSOR DATA ALREADY IN LINES AND REMOVE IT*/}

	    setLoading(true);
	    //vvvvv WILL BECOME REDUNDANT WITH SETAXES vvvvv//
	    var dts = graphUtil("getTimes")(start, end, 7);
		dts = graphUtil("getDates")(dts);
	    var midnights = graphUtil("getMidnights")(start, end); 
		//midnights = midnights.slice(1,midnights.length - 1);
		console.log(midnights);
		midnights = graphUtil("midnightGradient")(start, end, midnights);
		console.log(midnights);
		setGradient(midnights.gradient);

	    /*console.log("dates:");
	    //console.log(dts);*/

	    setDates(dts);
            axios.get('http://localhost:5000/api/aqi/time/' + start + "-" + end + '/' + sensor_id)
                .then(response => {
		    setError(null);
                    console.log(response);
		    setAxes(getAxes(response.data.data, start, end));
		    if (lineBool) {
                    	setLines(lines =>[...lines, {"data": response.data.data, "sensor": [sensor_id, getObj("$" + sensor_id)], "color": getObj("C" + sensor_id)}]);
		    }else{
			setAQI(response.data.data);
			const [brs, m] = graphUtil("getBars")(response.data.data.map(item => item[1]), nBars);
			setBars(brs);
			//console.log("bars" + bars);
			setMax(m);
		    }
                    setLoading(false);
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    setError(error.message);
                    setLoading(false);
                });
    	}, [sensor_id, start, end]);

	useEffect(() => {
		const [brs, m] = graphUtil("getBars")(AQI.map(item => item[1]), nBars);
		setBars(brs);
		setMax(m);
	}, [nBars]);

	useEffect(() => {
		setGlobalLineBool(lineBool);
	}, [lineBool]);

	useEffect(() => {
		const updateSize = () => {
			if (buttonRef.current && xAxisRef.current) {
				setXHeight(xAxisRef.current.getBoundingClientRect().height);
				const height = buttonRef.current.getBoundingClientRect().height;
				setButtonHeight(height);}
			if (divRef.current) {
				let {width,height} = divRef.current.getBoundingClientRect();
				width = width*.9;
				console.log("width: " + width + " height: " + height);
				setDivSize({width, height});
		        }
		};
		updateSize();
		window.addEventListener("resize", updateSize);
		return () => {window.removeEventListener("resize", updateSize);};
	}, []);




  const getAxes = (data) => {
    const xVals = data.map(item => item[0]);
    const yVals = data.map(item => item[1]);
    const start = Math.min(xVals);
    const end = Math.max(xVals);
    const ymax = Math.max(yVals);

    const xAxis = graphUtil("getMidnights")(start, end);
    const offset = (xAxis[0] - start)/width
    const unit_width = end-start
    const gap = 60*60*24
    const xPos_px = [Math.ceil(unit_width/gap)]; 
    let i = 0;
    while (offset < end){
	xPos_px[i++] = (offset-start)/unit_width;
	offset += gap;
    }
	
    const yAxis = graphUtil("linspace")(0, ymax, height/20);
    
    //SET AXES AS USESTATE or make axes obj to return
    return {"xVals": xAxis, "xPos": xPos_px, "yVals": yAxis}
  };

  const toggleLineBool = () => {
    let prevState = lineBool;
    setLineBool(!prevState); 
    setGlobalLineBool(!prevState);
  };

  const graphContainer = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    margin: '10px'
  };

  const graphElement = {
    display: 'flex',
    width: '100%',
    flexDirection: 'row',
    marginBottom: '5px',
    justifyContent: 'space-between',
  };

if (loading)
	{return (<div className="loading-message">Loading...</div>);}
if (error)
	{return (<div className="error-message">Error: {error}</div>);}

//TODO Add y-axis, fix x-axis
return (
    <div>
        <h1>7-Day AQI Readings</h1>
        <div style={{ display: "flex", alignItems: "flex-start" }}>
            {/* TODO: Add y axis */}
            <div><VertAxis values={axes.yVals} h={height + buttonHeight} bh = {buttonHeight}/></div>

            <div ref={divRef} style={{height: "100%", width:"100%"}}>
       		<button ref={buttonRef} onClick={toggleLineBool}>
            	    {lineBool ? "Switch to Bars View" : "Switch to Line Graph View"}
       		</button>
                {lineBool ? (
                    <LineGraph data={lines} gradient={gradient} w={divSize.width} h={height} />
                ) : (
                    <div
                        style={{
                            ...graphElement,
                            border: "1px solid black",
                            alignItems: "flex-end",
                            height: height + "px", // Fixed height
                            width: divSize.width + "px",  // width
                            background: gradient
                        }}
                    >
                        {bars.map((bar, index) => (
                            <Bar key={index} val={bar} max={max} />
                        ))}
                    </div>
                )}
                <div ref={xAxisRef} style={{ ...graphElement, height: "55px" }}>
                    {dates.map((date, index) => (
                        <DateComp key={index} text={date} />
                    ))}
                </div>
            </div>
        </div>
    </div>
);

}

export default Graph;